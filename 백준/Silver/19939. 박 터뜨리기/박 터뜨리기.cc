#include "iostream"
using namespace std;
int main(){

    //try
    // 바구니에 연속으로 담을 수 있도록 sum(1-k)개의 공이 있는지 확인
    // 해당 숫자 미만이라면, -1 출력 후 종료

    // n - sum(1~k) > 0 는 모든 바구니에 1 2 3 .... K의 갯수로 공을 채울 수 있다는 것을 의미한다.
    // n - sum(1~k) == 0 은 모든 바구니에 1 2 3 .... K의 갯수로 공을 채운 후 남는 공이 없다는것을 의미한다.
    // n - sum(1~k) > 0은 모든 바구니에 1 2 3 .... K의 갯수로 공을 채운 후 공이 남는것을 의미한다.
    // 이때, 남는 공을 k번째 바구니부터 거꾸로 채우면 첫 바구니와의 최소 차를 유지한 채로 모든 바구니 속 공 갯수가 다른 조건을 만족할 수 있다.
    // 또한 n - sum(1~k) > 0 이고, 이를 k로 나누었을 때, 나머지가 없다면 모든 바구니에 대하여 1개 또는 그 이상씩 채울 수 있으므로
    // 남는 공이 없는 경우와 같다. 
    // n - sum(1~k) % k >0 이라면, 거꾸로부터 바구니를 채우므로 첫 바구니와 마지막 바구니의 갯수차는 1-(k+1) 이므로 k이다.
    // p.s. ( n - sum(1~k) % k > 0 일때, 그 값은 1 ~ k-1이므로 모든 바구니를 채우지 못한다)

    //sol
    // 1. n - sum(1~k) % k = 0 이라면, 첫 바구니와 끝 바구니의 공 개수차가 k-1이므로 k-1 출력 후 종료
    // 2. n - sum(1~k) % k > 0 이라면, 첫 바구니와 끝 바구니의 공 개수차가 k이므로 k출력 후 종료

    int n,k; cin>>n>>k;
    int sum = 0;

    for(int i = 0; i<=k;i++){
        sum+=i;
    }
    if(n - sum < 0){
        cout<<-1;
        return 0;
    }

    if((n - sum) % k == 0){
        cout<<k-1;
    }else{
        cout<<k;
    }

    return 0;
}