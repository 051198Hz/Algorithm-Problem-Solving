#include "iostream"
using namespace std;
int main(){
    //case
    //1-5 2-4 3-4 5-6
    //4-5에 머물러야하기 때문에 1시간
    // 1-2 3-4 5-6
    //2-3, 4-5에 머물러야 하기 때문에 2시간

    //제일 빨리 떠나는 팬의 end시간과 제일 늦게 도착하는 팬의 start시간이 연관돼있음
    //머무는 시간이 겹치는 지 확인할 수 있는 방법이 있을까? -> 배열에 해당 시간에 ++하는 방법이 있음
    // 제일 빨리 떠나는 팬에게 인사해야 하기 때문에 그시간엔 반드시 있어야 함

    //try
    //배열을 만들어 각각의 시간에 해당하는 인덱스에 값을 ++하고
    //해당 인덱스의 배열값이 최대가 될 때를 좌우 배열값과 비교하여
    // 가장 많이 머물고 있는 시간대(가장 겹치는 시간대)를 알아내는 식으로 풀이에 접근하였음
    //그러나 한번 왕복의 조건을 잊고있었고(....)
    //만약 2명일 경우에, 4-5,6-7처럼
    //인덱스 5의 값은 1, 인덱스 6의 값은 1이며 누가 떠나거나 들어온것이 확인할 수 없었음
    //즉, 구간이 끊기는 것을 알 수 없는 방법이었으며 이를 팬의 숫자와 엮어 계산식을 세우려 시도했으나
    //문제의 난이도에 적합하지 않은 것 같아 풀이 포기.

    //sol
    //가장 빨리 떠나는 팬의 end 시간과, 가장 늦게 도착한 팬의 start시간
    //모든 팬에게 인사를 해야 하며, 가장 빨리 떠나는 팬과 가장 늦게 도착한 팬 사이에 있는 팬들은 무조건 포함이 될 것이다.
    //가장 빠르고 가장 늦을 것 이므로.
    //또한, 그 구간 사이의 각각의 부분 구간들에서는 인사할 수 있는 최대 팬의 수가 늘거나 줄거나 할텐데
    //이때 최대가 아닌 경우에 인사를 할 필요가 없기 때문에 학교에 머무를 필요가 없으나
    //욱제는 학교에 왕복하는 횟수는 반드시 1번이기 때문에
    //가장 빨리 떠나는 팬과 가장 늦게 도착한 팬에게 인사할 수 있는 시간동안 학교에 머물러야 한다.

    int n; cin>>n;
    int max = 0, min = 100001;

    for(int i = 0; i<n; i++){
        int start,end; cin>>start>>end;
        min = end < min ? end: min;
        max = start > max ? start : max;
    }
    if( max - min > 0){
        cout<<max-min;
    }else{
        cout<<0;
    }
    return 0;
}